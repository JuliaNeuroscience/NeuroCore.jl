<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaceing With NeuroCore · NeuroCore.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NeuroCore.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../anatomical_api/">Anatomical API</a></li><li><a class="tocitem" href="../spatial_api/">Spatial API</a></li><li><a class="tocitem" href="../color_channels/">Color Channels</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../introduction_properties/">Introduction to Properties</a></li><li><a class="tocitem" href="../imaging_metadata/">Imaging</a></li><li><a class="tocitem" href="../electrophysiology/">Electrophysiology</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>Interfaceing With NeuroCore</a><ul class="internal"><li><a class="tocitem" href="#Using-Existing-Array-Types-1"><span>Using Existing Array Types</span></a></li><li><a class="tocitem" href="#Using-Other-Array-Like-Types-1"><span>Using Other Array-Like Types</span></a></li><li><a class="tocitem" href="#Overload-Important-Methods-1"><span>Overload Important Methods</span></a></li></ul></li><li><a class="tocitem" href="../plots/">Plots</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interfaceing With NeuroCore</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfaceing With NeuroCore</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaNeuroscience/NeuroCore.jl/blob/master/docs/src/working_with_interface.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interfacing-With-NeuroCore-1"><a class="docs-heading-anchor" href="#Interfacing-With-NeuroCore-1">Interfacing With NeuroCore</a><a class="docs-heading-anchor-permalink" href="#Interfacing-With-NeuroCore-1" title="Permalink"></a></h1><p>The most important component of the NeuroCore interface is just an array type that has a predictable way of identifying important features and is compatible with well established libraries for composing algorithms. Therefore, the easiest way to use data structures that are compatible with the NeuroCore interface is to just use already supported array types. This doesn&#39;t prevent developers from creating their own compatible array types or simply taking advantage of Julia&#39;s multiple dispatch to exclusively interface with those methods needed.</p><h2 id="Using-Existing-Array-Types-1"><a class="docs-heading-anchor" href="#Using-Existing-Array-Types-1">Using Existing Array Types</a><a class="docs-heading-anchor-permalink" href="#Using-Existing-Array-Types-1" title="Permalink"></a></h2><p>The fully supported array types used in NeuroCore are derived from the <code>AxisIndices</code> package and are as follows...</p><ul><li><code>AxisArray</code></li><li><code>NamedAxisArray</code></li><li><code>MetaAxisArray</code></li><li><code>NamedMetaAxisArray</code></li></ul><p>...and here&#39;s a quick guide to the prefixes.</p><ul><li><code>Axis</code>: supports fancy indexing</li><li><code>Named</code>: supports named dimensions</li><li><code>Meta</code>: supports array level metadata </li></ul><p>The <code>NamedMetaAxisArray</code> type provides all the functionality that the other types do, so we&#39;ll be using it for most examples. Just be aware that the interface should be the same between each of these types where it makes sense (e.g., <code>NamedAxisArray</code> and <code>NamedMetaAxisArray</code> both use <code>dimnames</code> to return dimension names).</p><h3 id="From-IO-Streams-to-Arrays-1"><a class="docs-heading-anchor" href="#From-IO-Streams-to-Arrays-1">From IO Streams to Arrays</a><a class="docs-heading-anchor-permalink" href="#From-IO-Streams-to-Arrays-1" title="Permalink"></a></h3><p>The only information necessary for composing a new <code>NamedMetaAxisArray</code> are the dimension names, axes, and metadata. For example, let&#39;s say we have a 2-dimensional image of the brain in the coronal view and it is read into memory by a special streaming type <code>CoronalStream</code>. We&#39;ll assume that we know the dimension names are &quot;sagittal&quot; and &quot;axial&quot;, each axis is 50 millimeters long with 50 pixels, and we just want a simply <code>Int</code> type. We&#39;ll keep the metadata simple for know and only specify the institution name. Now let&#39;s use several different methods for composing our array.</p><pre><code class="language-julia">using NeuroCore

using Unitful: mm

function NeuroCore.NamedMetaAxisArray(s::CoronalStream)
    return NamedMetaAxisArray{(:sagittal, :axial)}(  # dimension names specified first as part of the type
        read!(s, Array{Int}(undef, (50, 50))),       # Read a standard array in
        (range(1, stop=50)mm, range(1, stop=50)mm),  # 
        institution_name = &quot;some institution&quot;        # metadata specified by key word
    )
end</code></pre><p>We could make this a lot more composable by breaking it down to the core components that make up the type though.</p><pre><code class="language-julia">NeuroCore.dimnames(::Type{&lt;:CoronalStream}) = (:sagittal, :axial)

NeuroCore.axes(s::CoronalStream) = (range(1, stop=50)mm, range(1, stop=50)mm)

NeuroCore.metadata(s::CoronalStream) = Dict{Symbol,Any}(institution_name =&gt; &quot;some institution&quot;)

Base.eltype(::Type{&lt;:CoronalStream) = Int

function NamedMetaAxisArray(x::CoronalStream)
    T = eltype(x)
    coronal_stream_axes = axes(x)
    A = AxisArray{T}(undef, coronal_stream_axes)
    read!(s, A)
    return NamedMetaAxisArray{dimnames(s)}(A, metadata=metadata(s))
end</code></pre><p>Note that the metadata is a reserved keyword for providing the collection of metadata Also note that metadata is expected to have a <code>Symbol</code> type as its keys. This allows metadata to be accessed like properties (e.g., <code>array_instance.institution_name</code>)</p><h2 id="Using-Other-Array-Like-Types-1"><a class="docs-heading-anchor" href="#Using-Other-Array-Like-Types-1">Using Other Array-Like Types</a><a class="docs-heading-anchor-permalink" href="#Using-Other-Array-Like-Types-1" title="Permalink"></a></h2><p>If for some reason the structure you want to use is like an array but isn&#39;t a subtype of an array (i.e. so you cannot wrap it in a <code>NamedMetaAxisArray</code>), then you can piece together whatever functionality you need using something like the following.</p><pre><code class="language-julia">using AxisIndices

using NamedDims

NamedDims.dimnames(::Type{&lt;:MatrixType}) = (:dim1_name, :dim2_name)

AxisIndices.metadata(x::MatrixType) = getfield(x, :metadata)

Base.parent(x::MatrixType) = getfield(x, :parent)

Base.@propagate_inbounds function Base.getindex(x::MatrixType, arg1::Int, arg2::Int)
    return getindex(parent(x), arg1, arg2)
end

Base.@propagate_inbounds function Base.getindex(x::MatrixType, arg1, arg2)
    return getindex(
        x,
        AxisIndices.to_index(axes(x, 1), arg1),
        AxisIndices.to_index(axes(x, 2), arg2)
    )
end

Base.@propagate_inbounds function Base.getindex(x::MatrixType; kwargs...)
    inds = NamedDims.order_named_inds(x; kwargs...)
    return getindex(x, inds...)
end

Base.getproperty(x::MatrixType, s::Symbol) = getproperty(metadata(x), s)

Base.setproperty!(x::MatrixType, s::Symbol, val) = setproperty!(metadata(x), s, val)

Base.propertynames(x::MatrixType) = propertynames(metadata(x))</code></pre><p>Let&#39;s run through this by each feature we&#39;re trying to support.</p><ol><li>Named dimensions: We need to be able to extract this with <code>dimnames</code>. In order to get nice named indexing we have to provide a version of getindex that uses keyword arguments.</li></ol><p>This won&#39;t provide named dimension interfaces for other functions (e.g., permutedims, etc.).   Each of these must be overloaded individually for the new type.</p><ol><li>Fancy indexing: accomplished through conversion of arguments at each axis via <code>AxisIndices.to_index</code>.</li></ol><p>This gets more involved if supporting arbitrary dimensions.</p><ol><li>Metadata: Main component is <code>AxisIndices.metadata</code>.</li></ol><p>The last 3 lines allow metadata to be treated like properties.   Note that if you do this fields cannot be accessed like properties.   For example, we assume that <code>MatrixType</code> wraps a parent structure but this cannot be accessed via <code>MatrixType.parent</code> anymore.</p><p>In addition to consulting the documentation for <code>NamedDims</code> or <code>AxisIndices</code>, users may be interested in Julia&#39;s documentation of the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array-1">array interface</a>.</p><h2 id="Overload-Important-Methods-1"><a class="docs-heading-anchor" href="#Overload-Important-Methods-1">Overload Important Methods</a><a class="docs-heading-anchor-permalink" href="#Overload-Important-Methods-1" title="Permalink"></a></h2><p>Up to this point we&#39;ve assumed that everything is an array or array-like. However, the same principles broadly apply to other data structures. For example, a structural connectome may be stored as an unordered collection of vectors of points. In this case the relation between the first and second fiber stored may have no spatial relationship. However, we can still use <code>Base.axes</code>, <code>NamedDims.dimnames</code>, etc. to provide information about the spatial orientation.</p><pre><code class="language-julia">struct Fibers{L,Axs}
    fibers::Vector{Vector{Point3f0}}
    axes::NamedTuple{L,Axs}
end

NeuroCore.dimnames(::Type{&lt;:Fibers{L,Axs}}) where {L,Axs} = L

Base.axes(f::Fibers) = values(getfield(f, :axes))</code></pre><p>This alone provides compatibility with most methods in <code>NeuroCore.SpatialAPI</code> and <code>NeuroCore.AnatomicalAPI</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../electrophysiology/">« Electrophysiology</a><a class="docs-footer-nextpage" href="../plots/">Plots »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 August 2020 17:59">Saturday 1 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
